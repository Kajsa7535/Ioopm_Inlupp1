M√•l att redovisa: 

M39: Pekare till pekare
F14: Svansrekursion?
TODO P45: G√∂r en informell kodgranskning under fas 1
P47: √Ötg√§rda defekter efter en kodgranskning
P48: St√§m av ett program mot en refactoringkatalog
TODO T56: Continuous Integration
U57: Byggverktyget Make
- "b√∂r inte g√∂ras f√∂rens sprint 2", men st√•r inte att man inte f√•r 


A1: Procedurell abstraktion
- Vi har till exempel skapat en funktion som kallas "calculate_bucket" (som fungerar f√∂r negativa tal) som anv√§nds p√• ett flertal st√§llen i koden. Detta hj√§lper eftersom det g√∂r koden mycket mer l√§sbar (och kortare!). Dessutom, om man beh√∂ver g√∂ra en √§ndring s√• beh√∂ver man enbart g√∂ra det i den nya proceduren, ist√§llet f√∂r att leta efter varje st√§lle den avnv√§nds p√•.
- "l√§ckande abstaktion": Bil exempel: En automat-bil √§r abstraherad, vi har en ratt, broms och gas. I en manuell bil s√• "l√§cker" abstaktionen genom att vi som anv√§ndare exempelvis kan accelerera f√∂r fort p√• en l√•g v√§xel s√• att bilen tar skada. I kod s√• kan samma sak ske; vi kan till exempel l√•ta anv√§ndaren g√∂ra n√•got som inte borde vara till√•tet eller att vi inte g√∂mmer saker som borde g√∂mmas, som om en bil inte g√∂mmer alla sina komponenter f√∂r k√∂raren. 
- Control abstaktion: Ser till att vi som prog rammerare inte beh√∂ver skriva alla bin√§ra steg varje g√•ng vi ska addera tv√• variabler eller likande. Det g√∂r det enklare att programmera och undvika fel. 
- Data abstaktion: V√•ra entries l√§ggs in i en hash table, som inte anv√§ndaren ser. Vi skulle lika v√§l kunna l√§gga in dem i en binary search tree eller n√•gon annan form av datastruktur. Det som anv√§ndaren ser, √§r att keys, values osv i entries, vilket √§r dem abstrakta egenskaperna, men sj√§lva implementationen √§r inte synlig. Data abstraktionen √§r att man kan se och anv√§nda interfacet, men inte sj√§lva datastrukturen. Tex hur v√•rt hashtable √§r uppbyggt, 
- ioopm_hash_table_destroy. "inkapslad" i flera olika funktioner som utf√∂r var sin "procedur". Funktionen ska "destroya" ett hashtable, minnet som man allokerat med calloc ska frig√∂ras. Namnen skulle kunna bli b√§ttre, om en person som inte l√§st koden innan och inte riktigt har koll p√• vad en bucket √§r kan bli lite f√∂rvirrad av v√•r hj√§lpfunktion "bucket_destroy" g√∂r f√∂r n√•got, sedan hade while/for loopen kunnat l√§ggas i en egen funktion f√∂r att "k√∂ra" den preceduren och g√∂ra l√§sbarheten √§nnu l√§ttare genom att ge den funktionen ett vettigt namn. 
- exempel p√• l√§ckande abstraktion: entry_destroy m√•ste man veta hur den ska anv√§ndas och n√§r man ska anv√§nda den, f√∂r att inte orsaka n√•got fel.
- L√•t ùëì1 ùëì2 och ùëì3 vara funktioner. ùëì1 och ùëì2 √§r delar av samma bibliotek och ùëì2 anv√§nder ùëì3 i sin implementation. Skiljer sig niv√•n av abstraktion mellan dessa p√• n√•got s√§tt? Hur? 
- SVAR: f3 √§r inkapslad i f2, vilket g√∂r att abstaktionsniv√•n skulle kunna vara h√∂gre i f2. Men samtidigt vet vi inte vad f√∂r funktioner f1 anroper, om den ens g√∂r det, och hur dessa √§r namngivna osv. 
- R√∂d tr√•d: En typ av abstraktion skulle kunna vara enhetstestning. Det "g√∂mmer" sig mycket bakom varje test, man ser bara funktionsanropen och namnen p√• testen. 

M39:  Pekare till pekare
- ioopm_hash_table_lookup, skickar in en pekare till en pekare till den f√∂rsta bokstaven i en st√§ng. (result)

----------------------------------------------------------------------------------------------------------------
Redovisning torsdag 16 september: 

M37: Anv√§nda pekare f√∂r att skapa l√§nkade strukturer
- V√•ra "buckets". "next" pekar p√• n√§sta entry vars next pekar p√• n√§st n√§sta entry osv. 

M38: V√§rde√∂verf√∂ring via pekare
- ioopm_hash_table_lookup, skickar in en pekare till en pekare till en str√§ng (f√∂rsta bokstaven i str√§ngen) f√∂r att i den callee-funktionen byta v√§rde p√• st√§ngen (genom att f√• pekaren/adressen till var st√§ngen finns i minnet) som anv√§nds i caller-funktionen. 

A3:  Informationsg√∂mning
- Sj√§lva tanken med .c och .h filer √§r att vi ska kunna anv√§nda de funktioner och typer som vi skapar i .c filer n√§r vi k√∂r och skriver andra program (i andra filer) utan att kopiera √∂ver funktionerna i den "nya" filen, vilket skulle g√∂ra att det blir v√§ldigt m√•nga rader kod i bara en fil (minskar l√§sbarheten och f√∂rst√•elsen). D√§rf√∂r kan man anv√§nda en .h fil som bara har deklarationer av funktionerna i korresponerande .c fil, vilket √§ven g√∂r det l√§tt f√∂r programmeraren att veta vad f√∂r funktiner som finns .c filen utan bl√§ddra igenom en massa kod. 
- EXEMPEL: Vi g√∂mmer structs till hash_table och entry i .h filen eftersom de anv√§nds o b√•de hash_table.c och hash_table_tests.c. P√• detta vis slipper vi ha funktionerna i b√•da filerna.

J27: Manuell minneshantering
- Hur uppst√•r minnesl√§ckage? 
    SVAR: Minnesl√§ckor uppst√•r n√§r man allokerar minne i heapen men gl√∂mmer att ta bort det med free(). Detta inneb√§r att minnesplatsen anv√§nds, men inte utnyttjas effektivt, och man har allts√• f√∂rlorat potentiell plats f√∂r att lagra n√•got annat. Detta kan resultera i att programmet k√∂rs l√•ngsammare och i v√§rsta fall kraschar. 
- Vilken del av ett program ansvarar f√∂r att frig√∂ra minne?
    SVAR: free()?
- N√§r avg√∂r man att en bit allokerat minne √§r ‚Äúf√§rdiganv√§nt‚Äù och g√•r att frig√∂ra?
    SVAR: N√§r det som √§r lagrat p√• det allokerade minnet inte l√§ngre kommet att beh√∂vas anv√§ndas. Dvs, det anv√§nds inte mer i n√•gon funktion och ger inte l√§ngre n√•got syfte.
- Vad kan h√§nda om ett allokerat utrymme frig√∂rs ‚Äúf√∂r tidigt‚Äù?
    SVAR: Man kan f√• dangling pointers, dvs pointers som pekar till minne som inte √§r allokerat. Detta inneb√§r att den datan som pointern pekar p√•, inte l√§ngre √§r giltig, och skulle kunne best√• av vad som helst som vi inte kar kontroll √∂ver och ingen aning om vad det √§r.
- P√• vilket s√§tt hj√§lper valgrind dig att undvika minnesl√§ckage?
    SVAR: Valgrind f√∂rklarar hur mycke minne som allokeras samt frig√∂rs under ett programs livstid. Om det √§r mer minne som allokeras √§n frig√∂rs s√• uppst√•r minnesl√§ckor.

---------------------------------------------------------------------------------------------------------------
Redovisning m√•ndag 20 September:

F13: Iteration vs. rekursion
- length_of_bucket_recursive vs. length_of_bucket
- Det kan vara sv√•rare f√∂r en person som inte √§r s√• van vid rekursiva funktioner att f√∂rst√• hur den rekursiva funktionen fungerar j√§mf√∂r med hur den itterativa funktionen fungerar. 
- Iterativa funktioner kan alltid bli rekursiva, men rekursiva kan inte alltid bli iterativa. Rekursivt menas med att funktionen anropar sig sj√§lv. 
- B√•da anv√§nder bara stacken, d√§rmed inte s√• stor skillnad i prestanda. Det √§r n√§mligen skillnad i prestanda n√§r man anv√§nder stacken och n√§r man anv√§nder heapen 
- R√ñD TR√ÖD: Iteration och rekursion (i alla fall v√•ra funktioner) har anv√§nt sig av stacken, vilket tar oss in p√• vad skillnaden p√• stacken och heapen √§r

J26: Allokering p√• stacken vs. p√• heapen
- Se redovisning.c fil
- Stacken tar mycket snabbare tid ?
- Stack. Last in first out. V√§rden l√§ggs som "tallrikar" p√• stacken. En tallrik tas bort n√§r resultatet returneras.
- Heap: Beh√∂ver free() f√∂r att inte f√• minnesl√§ckage, vilket g√∂r att det kr√§vs mer rader kod √§n om man anv√§nder stacken. Om man inte anv√§nder free() s√• kan det p√•verka prestandan negativt pga minnesl√§ckage. F√∂rdelen √§r att du kommer √•t dina v√§rden mellan funktioner d√• de sparas i heapen j√§mf√∂rt med stacken som "f√∂rsvinner"/skrivs √∂ver n√§r n√§sta funktion k√∂r. 
- N√§r en funktion bara anv√§nder sig av stacken s√• "f√∂rsvinner" det som l√•g d√§r n√§r funktionen √§r klar. Du f√•r bara det returv√§rdet funktionen returnerade. Men om man anv√§nder sig av heapen s√• kan man komma √•t det √§ven mellan olika funktioner, oavsett vad funktionerna returnerar. 
- J√§mf√∂relse med fib(35): Stack = 0s , Heap = 2.68s
- J√§mf√∂relse med fib(45): Stack = 8.55s, Heap = F√∂r l√•ng tid
- Slutsats: Om man kan h√•lla sig till stacken s√• b√∂r man g√∂ra det, eftersom den har mycket h√∂gre prestanda. Om det beh√∂vs en minnesplats s√• m√•ste man dock anv√§nda sig av heapen.
- R√ñD TR√ÖD: Minneshantering anv√§nder sig av pekare vilket tar oss vidare till M36, som handlar om arrayer och pekare. 

M36: C:s array-notation och pekararitmetik
- Argumentvektorn till main-funktionen
    SVAR: main(int argc, char *argv[]). Det som skickas in som argument till main blir en array.
- Vad √∂vers√§tts arr[42] till? 
    SVAR: Det 43:e elementet i arrayen "arr". Pga index b√∂rjar p√• 0. 
- Vad √∂vers√§tts 42[arr] till? (detta kompilerar faktiskt, trots att det ser vansinigt ut)
    SVAR: Samma; 43:e elementet i arrayen "arr". Se redovisning.c.
- Det som √§r innanf√∂r [] √§r offset fr√•n minnesplatsen, vilket inneb√§r att a[b] och b[a] ger samma adress.
- R√ñD TR√ÖD: Identitet pch ekvivalens h√∂r ihop med pekare

H19: Skillnaden mellan identitet och ekvivalens
- Identitet: "samma st√§ng". 
    char *test1 = "test"
    char *test2 = test1
- Ekvivalens: "Inneh√•ller samma st√§ng". tex en kopia av en str√§ng, det √§r tv√• str√§nger men de inneh√•ller likadan info
            En omodifierad kopia av original str√§ngen
    char *test1 = "Hej!"
    char *test2 = "Hej!"

---------------------------------------------------------------------------------------------------------------
Redovisning Torsdag 23 September:

R52: Debuggning med GDB

F14: Svansrekursion




REDOVISNING M√ÖNDAG 27 september:


E10: Man kan skapa generella funktioner genom att anv√§nda void-pekare, tex apply_all funktionen. 
Den kan i v√•rat exempel anv√§nda sig av tv√• olika hj√§lpfunktioner; value_equiv och key_equiv. Dessa hj√§lpfunktioner tar olika argumenttyper, vilket v√•r voidpekar-argument i apply_all funktionen m√∂jligg√∂r. C vet fr√•n b√∂rjan inte vad den ska tolka argumentet som f√∂r typ, men beroende p√• vilken hj√§lpfunktion man anv√§nder s√• tolkar den voidpekar-argumentet p√• olika s√§tt. Med detta sagt s√• har funktionen en viss genericitet.Vi kan visa det i v√•ra tester...

R√ñD TR√ÖD:
Nu har vi sett att vi kan ha olika typer av argument p√• samma funktion mha void-pekare i v√•ra tester, men hur vet vi att v√•ra tester √§r bra?

Q50: 
- Hur vet man att de test man har √§r ‚Äúbra‚Äù? 
    Ett bra enhetstest kan k√∂ras helt automatiserat, √§r l√§sbart och pr√∂var endast en enda logisk funktion/koncept. Man kan inte veta om ett test √§r bra. Det man kan resonera om √§r om ett test lyckas misslyckas, s√• hj√§lper det med att √•tg√§rda fel i en funktion, och d√§rmed √§r det bra eftersom det gjort nytta. 
- Hur vet man vad testen egentligen testar?
- Anv√§nd ett l√§mpligt verktyg f√∂r att t.ex. m√§ta code coverage, d.v.s. hur stor del av koden som faktiskt testas av testen. 
    Visa med ioopm_hash_table_remove: F√∂re test 7B och efter test 7B lagts till
- Vilka andra kvalitetsm√•tt p√• tester finns? 
    Hur l√§sbart det √§r? Om det t√§cker alla basfall och edgecases. LCOV, f√•r fram en code coverage report. 
- M√•ste man testa sina tester? 
    Nej man m√•ste "n√∂ja" sig n√•gonstanns. Annars kan man forts√§tta i alla o√§ndlighet. 
- M√•ste man testa testernas tester? Blir inte detta en o√§ndlig regression?


--------------------------------------------------------------------------------------------------------------------------------

REDOVISNING FREDAG 1 OKTOBER

I22: Defensiv programmering
- Defensiv programmering √§r en slags "approach" som ska f√∂rb√§ttra kod genom att minska antalet buggar och problem, se till att koden √§r l√§sbar och se till att programmet beter sig f√∂ruts√§gbart oavsett vilka inputs som anges.
- F√∂rdelarna med att ha defensiv programmering i √•tanke √§r bland annat att man undviker vissa fel som annars skulle tagit tid att √•tg√§rda.
- En typ av defensiv programmering √§r "offensiv programmering", som ist√§llet fokuserar p√• hur fel som uppst√•r utanf√∂r programmet hanteras. Man litar allts√• p√• att programmet fungerar och ist√§llet bara kollar att till exempel inputs √§r korrekta. EXEMPEL: ioopm_lookup_key i hash_table.c skriver ut "This key does not map to anything!" om inte s√∂kt key finns. Detta kan anv√§ndas som en check till andra funktioner f√∂r att kolla att en input √§r valid.
- Att √•teranv√§nda kod √§r en typ av defensiv programmering OM man har testat just den delen och vet att den fungerar. 
    EXEMPEL: F√∂rst skrev vi klart alla hash table funktioner och s√•g till att de fungerade med olika tester. N√§r vi sedan skulle b√∂rja med linked list s√• ins√•g vi att det var m√•nga v√§ldigt lika funktioner, och att en linked list s√•g v√§ldigt lik ut hur en bucket s√•g ut i ett hash table. Vi kunde d√§rf√∂r anv√§nda hur v√•r kod s√•g ut i hash table och f√∂ra √∂ver det till linked list funktionerna. TEX all, any och apply ta all funktionerna. 
- Assertions: kan skydda programmet fr√•n att utf√∂ra n√•got som inte √§r korrekt. Dessa b√∂r enbart anv√§ndas f√∂r saker som aldrig borde kunna uppst√•. EXEMPEL: linked list RAD 94, man ska aldrig kunna skicka in ett index som √§r utanf√∂r storleken p√• listan.
- Exceptions: Detta f√∂rklarar vi i felhanteringen
- Previllkor: Ett villkor eller predikat som m√•ste st√§mma INNAN en del av en kod utf√∂rs. Brukar inkluderas i dokumentationen av den delen av kod som det ber√∂r. EXEMPEL: linked_list_insert index m√•ste vara inom [0,N] d√§r N √§r l√§ngden p√• listan (st√•r i .h fil).
- Postvillkor: Ett villkor eller predikat som m√•ste st√§mma EFTER en del av en kod utf√∂rs. Assertions kan anv√§ndas f√∂r att testa om det st√§mmer. Brukar inkluderas i dokumentationen av den delen av kod som det ber√∂r. 
- Informationsg√∂mningsprincipen: Inkapsling √§r en typ av infomrationsg√∂mning. Man "g√∂mmer" saker bakom ett gr√§nssnitt. Informationsg√∂mning √§r viktigt f√∂r att skydda fr√•n l√§ckande abstaktioner. EXEMPEL: inkapsling i remove funktioner
- Hj√§lpfunktioner: Hj√§lper fel√∂kning genom att man kan testa en mindre del av koden i taget. EXEMPEL: find_previous_entry_for_key. TEX: find previous entry for key. Tidigare s√• fick vi en bugg i v√•r lookup funktion, som anv√§nder sig av find_previous_entry_for_key. Genom att g√∂ra testfall p√• den f√∂rst s√• kunde vi utesluta att det var i den delen av koden som buggen l√•g. 

- R√ñD TR√ÖD: Defensiv programmering √§r en typ av felhantering, vilket leder oss in p√• m√•l I24: "Olika metoder f√∂r felhantering".
- R√ñD TR√ÖD: Det kan g√• fel med aliasering tex och kan hittas med hj√§lp av defensiv programmering.

I24: Olika metoder f√∂r felhantering
- Crash don‚Äôt trash: Det √§r viktigt att uppt√§cka fel s√• fort som m√∂jligt. Om ett fel kan finnas fort s√• inneb√§r det att man kan l√•ta ett program krascha tidigare. F√∂rdelen med att krascha kan vara att man undviker att korrupt data skrivs och l√§ses. Med en krasch kan man ist√§llet f√• information om vad som g√•tt fel, ist√§llet f√∂r att f√• andra typer av fel.
- Defensiv programmering: Detta har vi redan f√∂rklarat. 
- Undantagshantering: Ett exception (eller undantag) √§r ett problem som uppst√•r vid utf√∂randet av ett program. N√§r ett exception uppst√•r s√• avbryts programmet, vilket inte alltid √§r eftertraktat, s√• ist√§llet s√• kan man hantera dessa undantag genom att "kasta" och "f√•nga" exceptions, s√• att det g√•r att k√∂ra vidare programmet. Ett try/catch block √§r ett sats som k√∂r en kod som √§r ben√§gen att orsaka exceptions i try-delen och om undantag uppst√•r s√• hanterar catch-delen det. Man kan ha flera catch-delar f√∂r olika typer av undantag. Om ett undantag inte hanteras s√• m√•ste man ange det med en "throw". Det g√•r att skriva sina egna undantag ocks√•. 
- Hur fel hanteras i C med errno: errno √§r en form av global variabel i C som indikerar errors som uppkommer under ett funktionsanrop. Det finns en header fil vid namn "error.h" d√§r olika errorkoder √§r definierade. Det finns √§ven perror() och sterror() funktioner som anv√§nds f√∂r att visa det textmeddelande som √§r kopplat till en viss errno errorkod. 
- Konsekvens att byta mellan felhanteringsmetoder i ett program: Man kommer beh√∂va skriva om sina funktioner och testa att de nya felhanteringmetoderna fungerar som f√∂rv√§ntat. 

G15: Aliasering
- Aliasering - data kan delas mellan olika objekt. En f√∂r√§ndring som sker via en pekare kan bli synlig f√∂r alla andra funktioner, eller liknande, som har en pekare till samma data. 
- Tex i linked_list.c har vi en remove funktion som tar bort det element ur listan som ligger p√• det index som man skickade in i funktionen. I v√•r struct s√• har vi first och last pekare, sedan s√• har vi √§ven pekare mellan elementen i listan. Om vi tex skulle ta bort det sista elementet i listan med hj√§lp av v√•r remove funktion s√• skulle listan pekas om (sista elementet frig√∂rs, det nya sista elementet pekar p√• null osv). Om vi nu skulle ta ut v√§rdet p√• list->last s√• skulle det ha √§ndrats om, utan att vi anv√§nt oss av last pekaren.
- Det h√§r kan vara ett problem ocks√•. Om vi hade gl√∂mt att peka om last pekaren n√§r vi tar bort det sista elementet s√• uppst√•r det problem. N√§r vi d√• f√∂rs√∂ker komma √•t datan med hj√§lp av last pekaren s√• kommer den f√∂rs√∂ka accessa minne som inte l√§ngre √§r allokerat.  
( KASNKE ON√ñDIGT? KAN SVARA OM DE FR√ÖGAR HUR MAN KAN UNDVIKA PROBELM - Ett s√§tt att undvika detta √§r att med hj√§lp av kopiering. Man kopierar d√• det v√§rde man beh√∂ver och kan d√• √§ndra p√• det ist√§llet. Men just i v√•rt fall s√• beh√∂vs inte det, d√• vi faktiskt vill √§ndra b√•de i listan och i last pekaren.)

--------------------------------------------------------------------------------------------------------------------------------------

REDOVISNING TISDAG 5 OKTOBER

DONE Z100: Inlupp 1
- Vi ska redovisa Z100, M39, O42 och O43 som alla h√∂r ihop eftersom vi gjort det p√• Inlupp 1.
- make memtest: Alla tester passed, inga memory leaks (k√∂rs genom valgrind)
- Visa tester: Vi kan inte visa alla tester, men vi kan ta n√•gra exempel fr√•n b√•da v√•ra testfiler.
    linked_list_tests.c:
    - test1_prepend: den ska testa att elementen s√§tts in r√§tt, dvs f√∂rst i listan. Om det √§r det f√∂rsta elementet som s√§tts in m√•nste vi kolla att last pekaren pekas om. Vi anv√§ndes oss av random, som tar fram 20 random element, pga loop 20 ggr, och och sedan kollar att listan har det elementet i sig och att first pekaren pekas om. Vi har redan gjort ett contains test, s√• vi vet att det fungerar. Sedan destroy s√• vi inte f√•r n√•gra memory leaks. 
    - V√•ra andra tester √§r uppbyggda p√• liknande s√§tt, vi anv√§nder oss av random i loopar, m√•nga asserts osv. 
    - test13_iterator_has_next, skapar en lista och sedan skapar vi en iterator p√• den listan. Vi k√∂r en loop som g√•r igenom hela listan, med hj√§lp av iterator, och kollar om den iteratorn har en n√§sta element. N√§r loopen √§r klar s√• ska den inte ha n√•gon next, den ska allts√• returnera false. N√§r det √§r falskt s√• k√∂r vi iterator_next en g√•ng till, vilket ska starta om iteratorn fr√•n b√∂rjan av listan igen. 
    hash_table.c
    - Alla tester √§r uppbyggda p√• ungef√§r samma s√§tt i alla test filer
    - test18 och 19, all och all not. F√∂rst l√§gger vi in samma values i alla entries i hash tablet och kollar att hash_table_all returnerar true, vi har skickat in ett predicate som ska j√§mf√∂ra ett tv√• values med varandra. Dvs den ska kolla att alla values i hash tablet √§r samma value. Sedan har vi skapat ett test d√§r vi skapar ett hash table, denna g√•ngen kollar den keys, med olika keys och values. N√§r vi sedan kollar hash_table_all s√• kommer den returnera falskt. 
- Visa dokumentation:
    Val och Avsteg fr√•n specifikationen:
    - Se "# Design Decisions" i README-fil. Visa d√• √§ven att vi har med hur man k√∂r med make, profiling resultat och code coverage.
    H-filer:
    - Visa att vi har funktionsspecifikationer och t.ex PREconditions (ioopm_hash_table_insert).


R√ñD TR√ÖD: Nu har vi kollat lite p√• olika delar av inl√§mningsuppgiften, s√• f√∂r att visa lite mer ska vi redovisa m√•len M39, O42 samt O43.


M39: Pekare till pekare
-  Vi n√§mnde att i v√•r hash table struct har vi anv√§nt oss av en dubbelpekare. Med detta har vi allts√• anv√§nt oss utav pekare till pekare f√∂r att slippa spcialfall f√∂r den f√∂rsta l√§nken (dummy entry eller sentinel entry) i en l√§nkad struktur. Vi ska nu visa lite mer detaljerat hur det g√•r till. 
- SE HASH TABLE STRUCT: "entry_t **buckets"
- SE HASH TABLE CREATE WITH LOAD: "entry_t **buckets = calloc(primes[index_primes], sizeof(entry_t *));". H√§r allokerar vi en minnesplats d√§r varje instans √§r size av en entry-pekare, allts√• en pekare till ett f√∂rsta entry i en bucket, och vi skapar lika m√•nga instanser av detta som det aktuella indexet i primtals-arrayen syftar p√•. 
- Vi kan √§ven se att funktionen "find_previous_entry_for_key_ptr" returnerar en dubbelpekare, eftersom den hittar pekaren till pekaren till den s√∂kta entry:n.


R√ñD TR√ÖD: Denna dubbelpekare √§r en form av optimering, vilket tar oss till v√•ra n√§sta tv√• m√•l att redovisa; O42 och O43 som b√•da √§r under titeln "Profilering och optimering".


O42: Profilering och optimering 1/3
- F√∂r O42 ska vi ta fram vilka delar av programmet som tar l√§ngst tid att k√∂ra respektive k√∂rs flest g√•nger. Detta kan vi g√∂ra med verktyget gprof. F√∂r tillf√§llet har vi ett make-kommando f√∂r att k√∂ra profileringen p√• programmet freq-count med filen 16k-words.txt.
- K√ñR: make gprof_freq-count
- Eftersom v√•rat program √§r optimerat f√∂r att vara effektivt mha rehashing s√• f√•r vi ingen tid i v√•rat resultat. Vi kan dock se hur m√•nga g√•nger funktionerna kallas p√•. Vi kan √§ven j√§mf√∂ra med olika load factors om vi vill se tid (ST√ÖR I README).
- Det √§r sv√•rt att argumentera varf√∂r denna data √§r r√§tt, men en ledning in p√• detta √§r att vi kan se att funktionern process_word k√∂rs ungef√§r 16-tusen g√•nger n√§r vi anv√§nder oss utav en fil som har ungef√§r 16-tusen ord. Vi kan d√• √§ven se att funktionen ioopm_lookup_key k√∂rs 16-tusen g√•nger, vilket √§r rimligt eftersom funktionen process_word kallar p√• ioopm_lookup_key.
- Vad √§r l√§mplig granularitetsniv√• p√• ‚Äúdelarna‚Äù som n√§mns ovan ‚Äì och varf√∂r?: Den granularitetsniv√•n som vi har nu √§r l√§mplig. Den visar oss hur ofta v√•ra egenskrivna funktioner kallas p√• och hur l√•ng tid det tar. Om vi skulle ha en h√∂gre detaljniv√• skulle profileringen kasnke visa hur m√•nga g√•nger standard-c-funktioner kallas p√•, men det √§r inte riktigt relevant i detta fall eftersom vi inte vill optimera standardbiblioteken.


R√ñD TR√ÖD: Med denna data kan vi se att vissa funktioner k√∂rs otroligt m√•nga g√•nger, och d√§rmed kan vi kanske optimera dem s√• att k√∂rningstiden f√∂rb√§ttras? Det √§r precis vad vi har gjort, och vi ska nu f√∂rklara det mer n√§r vi redovisar O43.


O43: Profilering och optimering 2/3
- Vi kunde se ovan att de funktioner som anv√§ndes mest och tog mest tid var framf√∂rallt find_previous_entry_for_key. Det vi kom fram till att det kunde bero p√• var att vi bara hade 17 buckets. S√• n√§r vi k√∂rde 16k words file s√• blir det v√§ldigt m√•nga entries i varje bucket, vilket g√∂r att det tar l√•ng tid f√∂r find_previous_entry for key att hitta r√§tt entry (s√§rsklit om den efters√∂kta entryn √§r l√§ngst bak i bucketen). 
- L√∂sningen p√• detta problem, dvs optimeringen, var att skapa en dynamisk storlektsf√∂r√§ndring av bucketstorleken. Vi gjorde om v√•r struktur s√• att den √§ven inneh√•ller en load factor och sedan ett index till v√•r array variabel, som inneh√•ller 11 olika storlekar som v√•r buckets kan inneh√•lla. 17, 31, 67 .... Vi kan visa hur v√•r gamla s√•g ut och hur den ser ut nu... Varje g√•ng det ska insertas en entry i hash tablet s√• kollar vi load factor (antal entries g√•nger load factor, och sedan j√§mf√∂r med antal buckets) om det visar sig att load factor blir f√∂r h√∂g s√• kommer vi att rehasha, dvs allokera nytt minne f√∂r buckets, men h√∂gre antal buckets, och sedan inserta om alla entries fr√•n de "gamla bucketserna" in i de nya. Sedan freeas de gamla. Vi √∂kar sedan p√• indexet p√• arrayen.
- Sedan s√• gjorde vi en till optimering, som vi pratade om i pekare till pekare m√•let. Vi tog bort dummy entries, vilket g√∂r att det inte kommer g√• on√∂dig tid p√• att g√• igenom en on√∂dig entry. Det kommer g√∂ra att i best case, bara vare en entry per bucket. Om vi t√§nker oss att vi har cirka 16-tusen olika buckets efter massa ins√§ttningar och dynamiska storleksf√∂r√§ndringar, s√• resulterar detta i att vi lyckats ta bort 16-tusen entries, vilket s√•klart minskar tiden f√∂r s√∂kfunktioner. 


--------------------------------------------------------------------------------------------------------------------------------------

FR√ÖGA X59: Ess√§
- Vilket m√•l p√• niv√• 4/5 √§r l√§mplig att redovisa med en ess√§?

FR√ÖGA TODO P45: G√∂r en informell kodgranskning under fas 1 
- N√§r √§r det l√§mpligt att g√∂ra denna?

Saker att g√∂ra / kom ih√•g!


Step 15:
- Code coverage report
- Automatisera allt med make-fil
- Dokumentera i readme-fil, l√§gg till instruktioner f√∂r hur man bygger och k√∂r, coverage f√∂r alla filer
- F√∂rbered presentation och hitta 3 m√•l att k√∂ra

-------------------------------------------------------------------------------------------------------------
GDB LATHUND:
 https://dev.to/jasonelwood/setup-gdb-on-macos-in-2020-489k (gdb f√∂r mac )

make hash_table

gdb ./a.out ./

b main (vart du vill ha breakpoint, tex b 147 (breakpoint p√• rad 147))

r - run (kom ih√•g argument om du har)

n - n√§sta rader

s - "steppa" in i funktionen du √§r vid

p - print value, vad det √§r just d√•.

q - quit

PLANERING:

Ca 1 step om dagen.
Ska vara klar till soft deadline
Ta ca 3-4 m√•l varje redovisning. Planerar ca 1/2 dagar innan redovisningstillf√§llet. 