MÃ¥l att redovisa: 

Vecka 37: 

M36: C:s array-notation och pekararitmetik
M37: AnvÃ¤nda pekare fÃ¶r att skapa lÃ¤nkade strukturer
M38: VÃ¤rdeÃ¶verfÃ¶ring via pekare fÃ¶r felhantering
M39: Pekare till pekare
A3:  InformationsgÃ¶mning
A1: Procedurell abstraktion
I24: Olika metoder fÃ¶r felhantering
F13: Iteration vs. rekursion
J27: Manuell minneshantering

Redovisning torsdag 16 september: 

A1: Procedurell abstraktion
- Vi har till exempel skapat en funktion som kallas "calculate_bucket" (som fungerar fÃ¶r negativa tal) som anvÃ¤nds pÃ¥ ett flertal stÃ¤llen i koden. 
- "lÃ¤ckande abstaktion": Bil exempel: En automat-bil Ã¤r abstraherad, vi har en ratt, broms och gas. I en manuell bil sÃ¥ "lÃ¤cker" abstaktionen genom att vi som anvÃ¤ndare exempelvis kan accelerera fÃ¶r fort pÃ¥ en lÃ¥g vÃ¤xel sÃ¥ att bilen tar skada. I kod sÃ¥ kan samma sak ske; vi kan till exempel lÃ¥ta anvÃ¤ndaren gÃ¶ra nÃ¥got som inte borde vara tillÃ¥tet eller att vi inte gÃ¶mmer saker som borde gÃ¶mmas, som om en bil inte gÃ¶mmer alla sina komponenter fÃ¶r kÃ¶raren. 
- Control abstaktion: Ser till att vi som programmerare inte behÃ¶ver skriva alla binÃ¤ra steg varje gÃ¥ng vi ska addera tvÃ¥ variabler eller likande. Det gÃ¶r det enklare att programmera och undvika fel. 
- Data abstaktion: VÃ¥ra entries lÃ¤ggs in i en hash table, som inte anvÃ¤ndaren ser. Vi skulle lika vÃ¤l kunna lÃ¤gga in dem i en binary search tree eller nÃ¥gon annan form av datastruktur. Det som anvÃ¤ndaren ser, Ã¤r att keys, values osv i entries, vilket Ã¤r dem abstrakta egenskaperna, men sjÃ¤lva implementationen Ã¤r inte synlig. Data abstraktionen Ã¤r att man kan se och anvÃ¤nda interfacet, men inte sjÃ¤lva datastrukturen.
- ioopm_hash_table_destroy. "inkapslad" i flera olika funktioner som utfÃ¶r var sin "procedur". Funktionen ska "destroya" ett hashtable, minnet som man allokerat med calloc ska frigÃ¶ras. Namnen skulle kunna bli bÃ¤ttre, om en person som inte lÃ¤st koden innan och inte riktigt har koll pÃ¥ vad en bucket Ã¤r kan bli lite fÃ¶rvirrad av vÃ¥r hjÃ¤lpfunktion "bucket_destroy" gÃ¶r fÃ¶r nÃ¥got, sedan hade while/for loopen kunnat lÃ¤ggas i en egen funktion fÃ¶r att "kÃ¶ra" den preceduren och gÃ¶ra lÃ¤sbarheten Ã¤nnu lÃ¤ttare genom att ge den funktionen ett vettigt namn. 
- exempel pÃ¥ lÃ¤ckande abstraktion: entry_destroy mÃ¥ste man veta hur den ska anvÃ¤ndas och nÃ¤r man ska anvÃ¤nda den, fÃ¶r att inte orsaka nÃ¥got fel.
- LÃ¥t ğ‘“1 ğ‘“2 och ğ‘“3 vara funktioner. ğ‘“1 och ğ‘“2 Ã¤r delar av samma bibliotek och ğ‘“2 anvÃ¤nder ğ‘“3 i sin implementation. Skiljer sig nivÃ¥n av abstraktion mellan dessa pÃ¥ nÃ¥got sÃ¤tt? Hur?

M37: AnvÃ¤nda pekare fÃ¶r att skapa lÃ¤nkade strukturer
- VÃ¥ra "buckets". "next" pekar pÃ¥ nÃ¤sta entry vars next pekar pÃ¥ nÃ¤st nÃ¤sta entry osv. 

M38: VÃ¤rdeÃ¶verfÃ¶ring via pekare fÃ¶r felhantering
- ioopm_hash_table_lookup, skickar in en pekare till en pekare till en strÃ¤ng (fÃ¶rsta bokstaven i strÃ¤ngen) fÃ¶r att i den callee-funktionen byta vÃ¤rde pÃ¥ stÃ¤ngen (genom att fÃ¥ pekaren/adressen till var stÃ¤ngen finns i minnet) som anvÃ¤nds i caller-funktionen. 

M39:  Pekare till pekare
- ioopm_hash_table_lookup, skickar in en pekare till en pekare till den fÃ¶rsta bokstaven i en stÃ¤ng. (result)

A3:  InformationsgÃ¶mning
- SjÃ¤lva tanken med .c och .h filer Ã¤r att vi ska kunna anvÃ¤nda de funktioner och typer som vi skapar i .c filer nÃ¤r vi kÃ¶r och skriver andra program (i andra filer) utan att kopiera Ã¶ver funktionerna i den "nya" filen, vilket skulle gÃ¶ra att det blir vÃ¤ldigt mÃ¥nga rader kod i bara en fil (minskar lÃ¤sbarheten och fÃ¶rstÃ¥elsen). DÃ¤rfÃ¶r kan man anvÃ¤nda en .h fil som bara har deklarationer av funktionerna i korresponerande .c fil, vilket Ã¤ven gÃ¶r det lÃ¤tt fÃ¶r programmeraren att veta vad fÃ¶r funktiner som finns .c filen utan blÃ¤ddra igenom en massa kod. 
- EXEMPEL: Vi gÃ¶mmer structs till hash_table och entry i .h filen eftersom de anvÃ¤nds o bÃ¥de hash_table.c och hash_table_tests.c. PÃ¥ detta vis slipper vi ha funktionerna i bÃ¥da filerna.

J27: Manuell minneshantering
- Hur uppstÃ¥r minneslÃ¤ckage? 
    SVAR: MinneslÃ¤ckor uppstÃ¥r nÃ¤r man allokerar minne i heapen men glÃ¶mmer att ta bort det med free(). Detta innebÃ¤r att minnesplatsen anvÃ¤nds, men inte utnyttjas effektivt, och man har alltsÃ¥ fÃ¶rlorat potentiell plats fÃ¶r att lagra nÃ¥got annat. Detta kan resultera i att programmet kÃ¶rs lÃ¥ngsammare och i vÃ¤rsta fall kraschar. 
- Vilken del av ett program ansvarar fÃ¶r att frigÃ¶ra minne?
    SVAR: free()?
- NÃ¤r avgÃ¶r man att en bit allokerat minne Ã¤r â€œfÃ¤rdiganvÃ¤ntâ€ och gÃ¥r att frigÃ¶ra?
    SVAR: NÃ¤r det som Ã¤r lagrat pÃ¥ det allokerade minnet inte lÃ¤ngre kommet att behÃ¶vas anvÃ¤ndas. Dvs, det anvÃ¤nds inte mer i nÃ¥gon funktion och ger inte lÃ¤ngre nÃ¥got syfte.
- Vad kan hÃ¤nda om ett allokerat utrymme frigÃ¶rs â€œfÃ¶r tidigtâ€?
    SVAR: Man kan fÃ¥ dangling pointers, dvs pointers som pekar till minne som inte Ã¤r allokerat. Detta innebÃ¤r att den datan som pointern pekar pÃ¥, inte lÃ¤ngre Ã¤r giltig, och skulle kunne bestÃ¥ av vad som helst som vi inte kar kontroll Ã¶ver och ingen aning om vad det Ã¤r.
- PÃ¥ vilket sÃ¤tt hjÃ¤lper valgrind dig att undvika minneslÃ¤ckage?
    SVAR: Valgrind fÃ¶rklarar hur mycke minne som allokeras samt frigÃ¶rs under ett programs livstid. Om det Ã¤r mer minne som allokeras Ã¤n frigÃ¶rs sÃ¥ uppstÃ¥r minneslÃ¤ckor, men om det Ã¤r mer som frigÃ¶rs Ã¤n allokeras sÃ¥ har man dangling pointers. 

Saker att gÃ¶ra / kom ihÃ¥g!

gdb lathund:

make hash_table

gdb ./a.out ./

b main (vart du vill ha breakpoint, tex b 147 (breakpoint pÃ¥ rad 147))

r - run (kom ihÃ¥g argument om du har)

n - nÃ¤sta rader

s - "steppa" in i funktionen du Ã¤r vid

p - print value, vad det Ã¤r just dÃ¥.

q - quit