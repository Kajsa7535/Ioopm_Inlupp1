M친l att redovisa: 

Vecka 37: 

M36: C:s array-notation och pekararitmetik
M37: Anv칛nda pekare f칬r att skapa l칛nkade strukturer
M38: V칛rde칬verf칬ring via pekare f칬r felhantering
M39: Pekare till pekare
A3:  Informationsg칬mning
A1: Procedurell abstraktion
I24: Olika metoder f칬r felhantering

Redovisning torsdag 16 september: 



A1: Procedurell abstraktion
- Vi har till exempel skapat en funktion som kallas "calculate_bucket" (som fungerar f칬r negativa tal) som anv칛nds p친 ett flertal st칛llen i koden. 
- "l칛ckande abstaktion": Bil exempel: En automat-bil 칛r abstraherad, vi har en ratt, broms och gas. I en manuell bil s친 "l칛cker" abstaktionen genom att vi som anv칛ndare exempelvis kan accelerera f칬r fort p친 en l친g v칛xel s친 att bilen tar skada. I kod s친 kan samma sak ske; vi kan till exempel l친ta anv칛ndaren g칬ra n친got som inte borde vara till친tet eller att vi inte g칬mmer saker som borde g칬mmas, som om en bil inte g칬mmer alla sina komponenter f칬r k칬raren. 
- Control abstaktion: Ser till att vi som programmerare inte beh칬ver skriva alla bin칛ra steg varje g친ng vi ska addera tv친 variabler eller likande. Det g칬r det enklare att programmera och undvika fel. 
- Data abstaktion: V친ra entries l칛ggs in i en hash table, som inte anv칛ndaren ser. Vi skulle lika v칛l kunna l칛gga in dem i en binary search tree eller n친gon annan form av datastruktur. Det som anv칛ndaren ser, 칛r att keys, values osv i entries, vilket 칛r dem abstrakta egenskaperna, men sj칛lva implementationen 칛r inte synlig. Data abstraktionen 칛r att man kan se och anv칛nda interfacet, men inte sj칛lva datastrukturen.
- ioopm_hash_table_destroy. "inkapslad" i flera olika funktioner som utf칬r var sin "procedur". Funktionen ska "destroya" ett hashtable, minnet som man allokerat med calloc ska frig칬ras. Namnen skulle kunna bli b칛ttre, om en person som inte l칛st koden innan och inte riktigt har koll p친 vad en bucket 칛r kan bli lite f칬rvirrad av v친r hj칛lpfunktion "bucket_destroy" g칬r f칬r n친got, sedan hade while/for loopen kunnat l칛ggas i en egen funktion f칬r att "k칬ra" den preceduren och g칬ra l칛sbarheten 칛nnu l칛ttare genom att ge den funktionen ett vettigt namn. 
- exempel p친 l칛ckande abstraktion: entry_destroy m친ste man veta hur den ska anv칛ndas och n칛r man ska anv칛nda den, f칬r att inte orsaka n친got fel.
- L친t 洧녭1 洧녭2 och 洧녭3 vara funktioner. 洧녭1 och 洧녭2 칛r delar av samma bibliotek och 洧녭2 anv칛nder 洧녭3 i sin implementation. Skiljer sig niv친n av abstraktion mellan dessa p친 n친got s칛tt? Hur?

M37: Anv칛nda pekare f칬r att skapa l칛nkade strukturer
- V친ra "buckets". "next" pekar p친 n칛sta entry vars next pekar p친 n칛st n칛sta entry osv. 

M38: V칛rde칬verf칬ring via pekare f칬r felhantering
- ioopm_hash_table_lookup, skickar in en pekare till en pekare till en str칛ng (f칬rsta bokstaven i str칛ngen) f칬r att i den callee-funktionen byta v칛rde p친 st칛ngen (genom att f친 pekaren/adressen till var st칛ngen finns i minnet) som anv칛nds i caller-funktionen. 

M39:  Pekare till pekare
- ioopm_hash_table_lookup, skickar in en pekare till en pekare till den f칬rsta bokstaven i en st칛ng. (result)

A3:  Informationsg칬mning
- Sj칛lva tanken med .c och .h filer 칛r att vi ska kunna anv칛nda de funktioner och typer som vi skapar i .c filer n칛r vi k칬r och skriver andra program (i andra filer) utan att kopiera 칬ver funktionerna i den "nya" filen, vilket skulle g칬ra att det blir v칛ldigt m친nga rader kod i bara en fil (minskar l칛sbarheten och f칬rst친elsen). D칛rf칬r kan man anv칛nda en .h fil som bara har deklarationer av funktionerna i korresponerande .c fil, vilket 칛ven g칬r det l칛tt f칬r programmeraren att veta vad f칬r funktiner som finns .c filen utan bl칛ddra igenom en massa kod. 
- EXEMPEL: Vi g칬mmer structs till hash_table och entry i .h filen eftersom de anv칛nds o b친de hash_table.c och hash_table_tests.c. P친 detta vis slipper vi ha funktionerna i b친da filerna.



Saker att g칬ra / kom ih친g!

gdb lathund:

make hash_table

gdb ./a.out ./

b main (vart du vill ha breakpoint, tex b 147 (breakpoint p친 rad 147))

r - run (kom ih친g argument om du har)

n - n칛sta rader

s - "steppa" in i funktionen du 칛r vid

p - print value, vad det 칛r just d친.

q - quit