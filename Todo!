M√•l att redovisa: 

M39: Pekare till pekare
E10: Implementera genericitet genom void-pekare
I22: Defensiv programmering
I24: Olika metoder f√∂r felhantering
F14: Svansrekursion?

A1: Procedurell abstraktion 
Q49: Enhetstestning
(Q50: M√§t och resonera kring testkvalitet FR√ÖGA OM HJ√ÑLP!!!!!)
- Verktyg f√∂r att kolla test coverage
R52: Debuggning med GDB
- Hitta en bugg (typ segmentation fault) som vi kan redovisa med

TODO T55: Mer Avacerad Versionhantering
- M√•ste l√§ra oss hur man g√∂r f√∂rst


A1: Procedurell abstraktion
- Vi har till exempel skapat en funktion som kallas "calculate_bucket" (som fungerar f√∂r negativa tal) som anv√§nds p√• ett flertal st√§llen i koden. Detta hj√§lper eftersom det g√∂r koden mycket mer l√§sbar (och kortare!). Dessutom, om man beh√∂ver g√∂ra en √§ndring s√• beh√∂ver man enbart g√∂ra det i den nya proceduren, ist√§llet f√∂r att leta efter varje st√§lle den avnv√§nds p√•.
- "l√§ckande abstaktion": Bil exempel: En automat-bil √§r abstraherad, vi har en ratt, broms och gas. I en manuell bil s√• "l√§cker" abstaktionen genom att vi som anv√§ndare exempelvis kan accelerera f√∂r fort p√• en l√•g v√§xel s√• att bilen tar skada. I kod s√• kan samma sak ske; vi kan till exempel l√•ta anv√§ndaren g√∂ra n√•got som inte borde vara till√•tet eller att vi inte g√∂mmer saker som borde g√∂mmas, som om en bil inte g√∂mmer alla sina komponenter f√∂r k√∂raren. 
- Control abstaktion: Ser till att vi som programmerare inte beh√∂ver skriva alla bin√§ra steg varje g√•ng vi ska addera tv√• variabler eller likande. Det g√∂r det enklare att programmera och undvika fel. 
- Data abstaktion: V√•ra entries l√§ggs in i en hash table, som inte anv√§ndaren ser. Vi skulle lika v√§l kunna l√§gga in dem i en binary search tree eller n√•gon annan form av datastruktur. Det som anv√§ndaren ser, √§r att keys, values osv i entries, vilket √§r dem abstrakta egenskaperna, men sj√§lva implementationen √§r inte synlig. Data abstraktionen √§r att man kan se och anv√§nda interfacet, men inte sj√§lva datastrukturen. Tex hur v√•rt hashtable √§r uppbyggt, 
- ioopm_hash_table_destroy. "inkapslad" i flera olika funktioner som utf√∂r var sin "procedur". Funktionen ska "destroya" ett hashtable, minnet som man allokerat med calloc ska frig√∂ras. Namnen skulle kunna bli b√§ttre, om en person som inte l√§st koden innan och inte riktigt har koll p√• vad en bucket √§r kan bli lite f√∂rvirrad av v√•r hj√§lpfunktion "bucket_destroy" g√∂r f√∂r n√•got, sedan hade while/for loopen kunnat l√§ggas i en egen funktion f√∂r att "k√∂ra" den preceduren och g√∂ra l√§sbarheten √§nnu l√§ttare genom att ge den funktionen ett vettigt namn. 
- exempel p√• l√§ckande abstraktion: entry_destroy m√•ste man veta hur den ska anv√§ndas och n√§r man ska anv√§nda den, f√∂r att inte orsaka n√•got fel.
- L√•t ùëì1 ùëì2 och ùëì3 vara funktioner. ùëì1 och ùëì2 √§r delar av samma bibliotek och ùëì2 anv√§nder ùëì3 i sin implementation. Skiljer sig niv√•n av abstraktion mellan dessa p√• n√•got s√§tt? Hur? 
- SVAR: f3 √§r inkapslad i f2, vilket g√∂r att abstaktionsniv√•n skulle kunna vara h√∂gre i f2. Men samtidigt vet vi inte vad f√∂r funktioner f1 anroper, om den ens g√∂r det, och hur dessa √§r namngivna osv. 
- R√∂d tr√•d: En typ av abstraktion skulle kunna vara enhetstestning. Det "g√∂mmer" sig mycket bakom varje test, man ser bara funktionsanropen och namnen p√• testen. 

M39:  Pekare till pekare
- ioopm_hash_table_lookup, skickar in en pekare till en pekare till den f√∂rsta bokstaven i en st√§ng. (result)

----------------------------------------------------------------------------------------------------------------
Redovisning torsdag 16 september: 

M37: Anv√§nda pekare f√∂r att skapa l√§nkade strukturer
- V√•ra "buckets". "next" pekar p√• n√§sta entry vars next pekar p√• n√§st n√§sta entry osv. 

M38: V√§rde√∂verf√∂ring via pekare
- ioopm_hash_table_lookup, skickar in en pekare till en pekare till en str√§ng (f√∂rsta bokstaven i str√§ngen) f√∂r att i den callee-funktionen byta v√§rde p√• st√§ngen (genom att f√• pekaren/adressen till var st√§ngen finns i minnet) som anv√§nds i caller-funktionen. 

A3:  Informationsg√∂mning
- Sj√§lva tanken med .c och .h filer √§r att vi ska kunna anv√§nda de funktioner och typer som vi skapar i .c filer n√§r vi k√∂r och skriver andra program (i andra filer) utan att kopiera √∂ver funktionerna i den "nya" filen, vilket skulle g√∂ra att det blir v√§ldigt m√•nga rader kod i bara en fil (minskar l√§sbarheten och f√∂rst√•elsen). D√§rf√∂r kan man anv√§nda en .h fil som bara har deklarationer av funktionerna i korresponerande .c fil, vilket √§ven g√∂r det l√§tt f√∂r programmeraren att veta vad f√∂r funktiner som finns .c filen utan bl√§ddra igenom en massa kod. 
- EXEMPEL: Vi g√∂mmer structs till hash_table och entry i .h filen eftersom de anv√§nds o b√•de hash_table.c och hash_table_tests.c. P√• detta vis slipper vi ha funktionerna i b√•da filerna.

J27: Manuell minneshantering
- Hur uppst√•r minnesl√§ckage? 
    SVAR: Minnesl√§ckor uppst√•r n√§r man allokerar minne i heapen men gl√∂mmer att ta bort det med free(). Detta inneb√§r att minnesplatsen anv√§nds, men inte utnyttjas effektivt, och man har allts√• f√∂rlorat potentiell plats f√∂r att lagra n√•got annat. Detta kan resultera i att programmet k√∂rs l√•ngsammare och i v√§rsta fall kraschar. 
- Vilken del av ett program ansvarar f√∂r att frig√∂ra minne?
    SVAR: free()?
- N√§r avg√∂r man att en bit allokerat minne √§r ‚Äúf√§rdiganv√§nt‚Äù och g√•r att frig√∂ra?
    SVAR: N√§r det som √§r lagrat p√• det allokerade minnet inte l√§ngre kommet att beh√∂vas anv√§ndas. Dvs, det anv√§nds inte mer i n√•gon funktion och ger inte l√§ngre n√•got syfte.
- Vad kan h√§nda om ett allokerat utrymme frig√∂rs ‚Äúf√∂r tidigt‚Äù?
    SVAR: Man kan f√• dangling pointers, dvs pointers som pekar till minne som inte √§r allokerat. Detta inneb√§r att den datan som pointern pekar p√•, inte l√§ngre √§r giltig, och skulle kunne best√• av vad som helst som vi inte kar kontroll √∂ver och ingen aning om vad det √§r.
- P√• vilket s√§tt hj√§lper valgrind dig att undvika minnesl√§ckage?
    SVAR: Valgrind f√∂rklarar hur mycke minne som allokeras samt frig√∂rs under ett programs livstid. Om det √§r mer minne som allokeras √§n frig√∂rs s√• uppst√•r minnesl√§ckor.

---------------------------------------------------------------------------------------------------------------
Redovisning m√•ndag 20 September:

F13: Iteration vs. rekursion
- length_of_bucket_recursive vs. length_of_bucket
- Det kan vara sv√•rare f√∂r en person som inte √§r s√• van vid rekursiva funktioner att f√∂rst√• hur den rekursiva funktionen fungerar j√§mf√∂r med hur den itterativa funktionen fungerar. 
- Iterativa funktioner kan alltid bli rekursiva, men rekursiva kan inte alltid bli iterativa. Rekursivt menas med att funktionen anropar sig sj√§lv. 
- B√•da anv√§nder bara stacken, d√§rmed inte s√• stor skillnad i prestanda. Det √§r n√§mligen skillnad i prestanda n√§r man anv√§nder stacken och n√§r man anv√§nder heapen 
- R√ñD TR√ÖD: Iteration och rekursion (i alla fall v√•ra funktioner) har anv√§nt sig av stacken, vilket tar oss in p√• vad skillnaden p√• stacken och heapen √§r

J26: Allokering p√• stacken vs. p√• heapen
- Se redovisning.c fil
- Stacken tar mycket snabbare tid ?
- Stack. Last in first out. V√§rden l√§ggs som "tallrikar" p√• stacken. En tallrik tas bort n√§r resultatet returneras.
- Heap: Beh√∂ver free() f√∂r att inte f√• minnesl√§ckage, vilket g√∂r att det kr√§vs mer rader kod √§n om man anv√§nder stacken. Om man inte anv√§nder free() s√• kan det p√•verka prestandan negativt pga minnesl√§ckage. F√∂rdelen √§r att du kommer √•t dina v√§rden mellan funktioner d√• de sparas i heapen j√§mf√∂rt med stacken som "f√∂rsvinner"/skrivs √∂ver n√§r n√§sta funktion k√∂r. 
- N√§r en funktion bara anv√§nder sig av stacken s√• "f√∂rsvinner" det som l√•g d√§r n√§r funktionen √§r klar. Du f√•r bara det returv√§rdet funktionen returnerade. Men om man anv√§nder sig av heapen s√• kan man komma √•t det √§ven mellan olika funktioner, oavsett vad funktionerna returnerar. 
- J√§mf√∂relse med fib(35): Stack = 0s , Heap = 2.68s
- J√§mf√∂relse med fib(45): Stack = 8.55s, Heap = F√∂r l√•ng tid
- Slutsats: Om man kan h√•lla sig till stacken s√• b√∂r man g√∂ra det, eftersom den har mycket h√∂gre prestanda. Om det beh√∂vs en minnesplats s√• m√•ste man dock anv√§nda sig av heapen.
- R√ñD TR√ÖD: Minneshantering anv√§nder sig av pekare vilket tar oss vidare till M36, som handlar om arrayer och pekare. 

M36: C:s array-notation och pekararitmetik
- Argumentvektorn till main-funktionen
    SVAR: main(int argc, char *argv[]). Det som skickas in som argument till main blir en array.
- Vad √∂vers√§tts arr[42] till? 
    SVAR: Det 43:e elementet i arrayen "arr". Pga index b√∂rjar p√• 0. 
- Vad √∂vers√§tts 42[arr] till? (detta kompilerar faktiskt, trots att det ser vansinigt ut)
    SVAR: Samma; 43:e elementet i arrayen "arr". Se redovisning.c.
- Det som √§r innanf√∂r [] √§r offset fr√•n minnesplatsen, vilket inneb√§r att a[b] och b[a] ger samma adress.
- R√ñD TR√ÖD: Identitet pch ekvivalens h√∂r ihop med pekare

H19: Skillnaden mellan identitet och ekvivalens
- Identitet: "samma st√§ng". 
    char *test1 = "test"
    char *test2 = test1
- Ekvivalens: "Inneh√•ller samma st√§ng". tex en kopia av en str√§ng, det √§r tv√• str√§nger men de inneh√•ller likadan info
            En omodifierad kopia av original str√§ngen
    char *test1 = "Hej!"
    char *test2 = "Hej!"

---------------------------------------------------------------------------------------------------------------
Redovisning Torsdag 23 September:

R52: Debuggning med GDB

F14: Svansrekursion


FR√ÖGA X59: Ess√§
- Vilket m√•l p√• niv√• 4/5 √§r l√§mplig att redovisa med en ess√§?

FR√ÖGA TODO P45: G√∂r en informell kodgranskning under fas 1 
- N√§r √§r det l√§mpligt att g√∂ra denna?

Saker att g√∂ra / kom ih√•g!

-------------------------------------------------------------------------------------------------------------
GDB LATHUND:
 https://dev.to/jasonelwood/setup-gdb-on-macos-in-2020-489k (gdb f√∂r mac )

make hash_table

gdb ./a.out ./

b main (vart du vill ha breakpoint, tex b 147 (breakpoint p√• rad 147))

r - run (kom ih√•g argument om du har)

n - n√§sta rader

s - "steppa" in i funktionen du √§r vid

p - print value, vad det √§r just d√•.

q - quit

PLANERING:

Ca 1 step om dagen.
Ska vara klar till soft deadline
Ta ca 3-4 m√•l varje redovisning. Planerar ca 1/2 dagar innan redovisningstillf√§llet. 