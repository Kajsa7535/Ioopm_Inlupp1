M√•l att redovisa: 

Vecka 37: 

M36: C:s array-notation och pekararitmetik
M37: Anv√§nda pekare f√∂r att skapa l√§nkade strukturer
M38: V√§rde√∂verf√∂ring via pekare f√∂r felhantering
M39: Pekare till pekare
A3:  Informationsg√∂mning
A1: Procedurell abstraktion
I24: Olika metoder f√∂r felhantering
F13: Iteration vs. rekursion
J27: Manuell minneshantering

A1: Procedurell abstraktion
- Vi har till exempel skapat en funktion som kallas "calculate_bucket" (som fungerar f√∂r negativa tal) som anv√§nds p√• ett flertal st√§llen i koden. 
- "l√§ckande abstaktion": Bil exempel: En automat-bil √§r abstraherad, vi har en ratt, broms och gas. I en manuell bil s√• "l√§cker" abstaktionen genom att vi som anv√§ndare exempelvis kan accelerera f√∂r fort p√• en l√•g v√§xel s√• att bilen tar skada. I kod s√• kan samma sak ske; vi kan till exempel l√•ta anv√§ndaren g√∂ra n√•got som inte borde vara till√•tet eller att vi inte g√∂mmer saker som borde g√∂mmas, som om en bil inte g√∂mmer alla sina komponenter f√∂r k√∂raren. 
- Control abstaktion: Ser till att vi som programmerare inte beh√∂ver skriva alla bin√§ra steg varje g√•ng vi ska addera tv√• variabler eller likande. Det g√∂r det enklare att programmera och undvika fel. 
- Data abstaktion: V√•ra entries l√§ggs in i en hash table, som inte anv√§ndaren ser. Vi skulle lika v√§l kunna l√§gga in dem i en binary search tree eller n√•gon annan form av datastruktur. Det som anv√§ndaren ser, √§r att keys, values osv i entries, vilket √§r dem abstrakta egenskaperna, men sj√§lva implementationen √§r inte synlig. Data abstraktionen √§r att man kan se och anv√§nda interfacet, men inte sj√§lva datastrukturen.
- ioopm_hash_table_destroy. "inkapslad" i flera olika funktioner som utf√∂r var sin "procedur". Funktionen ska "destroya" ett hashtable, minnet som man allokerat med calloc ska frig√∂ras. Namnen skulle kunna bli b√§ttre, om en person som inte l√§st koden innan och inte riktigt har koll p√• vad en bucket √§r kan bli lite f√∂rvirrad av v√•r hj√§lpfunktion "bucket_destroy" g√∂r f√∂r n√•got, sedan hade while/for loopen kunnat l√§ggas i en egen funktion f√∂r att "k√∂ra" den preceduren och g√∂ra l√§sbarheten √§nnu l√§ttare genom att ge den funktionen ett vettigt namn. 
- exempel p√• l√§ckande abstraktion: entry_destroy m√•ste man veta hur den ska anv√§ndas och n√§r man ska anv√§nda den, f√∂r att inte orsaka n√•got fel.
- L√•t ùëì1 ùëì2 och ùëì3 vara funktioner. ùëì1 och ùëì2 √§r delar av samma bibliotek och ùëì2 anv√§nder ùëì3 i sin implementation. Skiljer sig niv√•n av abstraktion mellan dessa p√• n√•got s√§tt? Hur?

M39:  Pekare till pekare
- ioopm_hash_table_lookup, skickar in en pekare till en pekare till den f√∂rsta bokstaven i en st√§ng. (result)


Redovisning torsdag 16 september: 

M37: Anv√§nda pekare f√∂r att skapa l√§nkade strukturer
- V√•ra "buckets". "next" pekar p√• n√§sta entry vars next pekar p√• n√§st n√§sta entry osv. 

M38: V√§rde√∂verf√∂ring via pekare
- ioopm_hash_table_lookup, skickar in en pekare till en pekare till en str√§ng (f√∂rsta bokstaven i str√§ngen) f√∂r att i den callee-funktionen byta v√§rde p√• st√§ngen (genom att f√• pekaren/adressen till var st√§ngen finns i minnet) som anv√§nds i caller-funktionen. 

A3:  Informationsg√∂mning
- Sj√§lva tanken med .c och .h filer √§r att vi ska kunna anv√§nda de funktioner och typer som vi skapar i .c filer n√§r vi k√∂r och skriver andra program (i andra filer) utan att kopiera √∂ver funktionerna i den "nya" filen, vilket skulle g√∂ra att det blir v√§ldigt m√•nga rader kod i bara en fil (minskar l√§sbarheten och f√∂rst√•elsen). D√§rf√∂r kan man anv√§nda en .h fil som bara har deklarationer av funktionerna i korresponerande .c fil, vilket √§ven g√∂r det l√§tt f√∂r programmeraren att veta vad f√∂r funktiner som finns .c filen utan bl√§ddra igenom en massa kod. 
- EXEMPEL: Vi g√∂mmer structs till hash_table och entry i .h filen eftersom de anv√§nds o b√•de hash_table.c och hash_table_tests.c. P√• detta vis slipper vi ha funktionerna i b√•da filerna.

J27: Manuell minneshantering
- Hur uppst√•r minnesl√§ckage? 
    SVAR: Minnesl√§ckor uppst√•r n√§r man allokerar minne i heapen men gl√∂mmer att ta bort det med free(). Detta inneb√§r att minnesplatsen anv√§nds, men inte utnyttjas effektivt, och man har allts√• f√∂rlorat potentiell plats f√∂r att lagra n√•got annat. Detta kan resultera i att programmet k√∂rs l√•ngsammare och i v√§rsta fall kraschar. 
- Vilken del av ett program ansvarar f√∂r att frig√∂ra minne?
    SVAR: free()?
- N√§r avg√∂r man att en bit allokerat minne √§r ‚Äúf√§rdiganv√§nt‚Äù och g√•r att frig√∂ra?
    SVAR: N√§r det som √§r lagrat p√• det allokerade minnet inte l√§ngre kommet att beh√∂vas anv√§ndas. Dvs, det anv√§nds inte mer i n√•gon funktion och ger inte l√§ngre n√•got syfte.
- Vad kan h√§nda om ett allokerat utrymme frig√∂rs ‚Äúf√∂r tidigt‚Äù?
    SVAR: Man kan f√• dangling pointers, dvs pointers som pekar till minne som inte √§r allokerat. Detta inneb√§r att den datan som pointern pekar p√•, inte l√§ngre √§r giltig, och skulle kunne best√• av vad som helst som vi inte kar kontroll √∂ver och ingen aning om vad det √§r.
- P√• vilket s√§tt hj√§lper valgrind dig att undvika minnesl√§ckage?
    SVAR: Valgrind f√∂rklarar hur mycke minne som allokeras samt frig√∂rs under ett programs livstid. Om det √§r mer minne som allokeras √§n frig√∂rs s√• uppst√•r minnesl√§ckor, men om det √§r mer som frig√∂rs √§n allokeras s√• har man dangling pointers. 

Saker att g√∂ra / kom ih√•g!


GDB LATHUND:
 https://dev.to/jasonelwood/setup-gdb-on-macos-in-2020-489k (gdb f√∂r mac )

make hash_table

gdb ./a.out ./

b main (vart du vill ha breakpoint, tex b 147 (breakpoint p√• rad 147))

r - run (kom ih√•g argument om du har)

n - n√§sta rader

s - "steppa" in i funktionen du √§r vid

p - print value, vad det √§r just d√•.

q - quit