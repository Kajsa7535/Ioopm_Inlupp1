M√•l att redovisa: 

M39: Pekare till pekare
- iterator remove
I22: Defensiv programmering
I24: Olika metoder f√∂r felhantering
F14: Svansrekursion?
G15: Aliasering
- Const
TODO P45: G√∂r en informell kodgranskning under fas 1
P47: √Ötg√§rda defekter efter en kodgranskning
P48: St√§m av ett program mot en refactoringkatalog
TODO T56: Continuous Integration
U57: Byggverktyget Make
- "b√∂r inte g√∂ras f√∂rens sprint 2", men st√•r inte att man inte f√•r 
G15: fr√•n step 12


A1: Procedurell abstraktion
- Vi har till exempel skapat en funktion som kallas "calculate_bucket" (som fungerar f√∂r negativa tal) som anv√§nds p√• ett flertal st√§llen i koden. Detta hj√§lper eftersom det g√∂r koden mycket mer l√§sbar (och kortare!). Dessutom, om man beh√∂ver g√∂ra en √§ndring s√• beh√∂ver man enbart g√∂ra det i den nya proceduren, ist√§llet f√∂r att leta efter varje st√§lle den avnv√§nds p√•.
- "l√§ckande abstaktion": Bil exempel: En automat-bil √§r abstraherad, vi har en ratt, broms och gas. I en manuell bil s√• "l√§cker" abstaktionen genom att vi som anv√§ndare exempelvis kan accelerera f√∂r fort p√• en l√•g v√§xel s√• att bilen tar skada. I kod s√• kan samma sak ske; vi kan till exempel l√•ta anv√§ndaren g√∂ra n√•got som inte borde vara till√•tet eller att vi inte g√∂mmer saker som borde g√∂mmas, som om en bil inte g√∂mmer alla sina komponenter f√∂r k√∂raren. 
- Control abstaktion: Ser till att vi som prog rammerare inte beh√∂ver skriva alla bin√§ra steg varje g√•ng vi ska addera tv√• variabler eller likande. Det g√∂r det enklare att programmera och undvika fel. 
- Data abstaktion: V√•ra entries l√§ggs in i en hash table, som inte anv√§ndaren ser. Vi skulle lika v√§l kunna l√§gga in dem i en binary search tree eller n√•gon annan form av datastruktur. Det som anv√§ndaren ser, √§r att keys, values osv i entries, vilket √§r dem abstrakta egenskaperna, men sj√§lva implementationen √§r inte synlig. Data abstraktionen √§r att man kan se och anv√§nda interfacet, men inte sj√§lva datastrukturen. Tex hur v√•rt hashtable √§r uppbyggt, 
- ioopm_hash_table_destroy. "inkapslad" i flera olika funktioner som utf√∂r var sin "procedur". Funktionen ska "destroya" ett hashtable, minnet som man allokerat med calloc ska frig√∂ras. Namnen skulle kunna bli b√§ttre, om en person som inte l√§st koden innan och inte riktigt har koll p√• vad en bucket √§r kan bli lite f√∂rvirrad av v√•r hj√§lpfunktion "bucket_destroy" g√∂r f√∂r n√•got, sedan hade while/for loopen kunnat l√§ggas i en egen funktion f√∂r att "k√∂ra" den preceduren och g√∂ra l√§sbarheten √§nnu l√§ttare genom att ge den funktionen ett vettigt namn. 
- exempel p√• l√§ckande abstraktion: entry_destroy m√•ste man veta hur den ska anv√§ndas och n√§r man ska anv√§nda den, f√∂r att inte orsaka n√•got fel.
- L√•t ùëì1 ùëì2 och ùëì3 vara funktioner. ùëì1 och ùëì2 √§r delar av samma bibliotek och ùëì2 anv√§nder ùëì3 i sin implementation. Skiljer sig niv√•n av abstraktion mellan dessa p√• n√•got s√§tt? Hur? 
- SVAR: f3 √§r inkapslad i f2, vilket g√∂r att abstaktionsniv√•n skulle kunna vara h√∂gre i f2. Men samtidigt vet vi inte vad f√∂r funktioner f1 anroper, om den ens g√∂r det, och hur dessa √§r namngivna osv. 
- R√∂d tr√•d: En typ av abstraktion skulle kunna vara enhetstestning. Det "g√∂mmer" sig mycket bakom varje test, man ser bara funktionsanropen och namnen p√• testen. 

M39:  Pekare till pekare
- ioopm_hash_table_lookup, skickar in en pekare till en pekare till den f√∂rsta bokstaven i en st√§ng. (result)

----------------------------------------------------------------------------------------------------------------
Redovisning torsdag 16 september: 

M37: Anv√§nda pekare f√∂r att skapa l√§nkade strukturer
- V√•ra "buckets". "next" pekar p√• n√§sta entry vars next pekar p√• n√§st n√§sta entry osv. 

M38: V√§rde√∂verf√∂ring via pekare
- ioopm_hash_table_lookup, skickar in en pekare till en pekare till en str√§ng (f√∂rsta bokstaven i str√§ngen) f√∂r att i den callee-funktionen byta v√§rde p√• st√§ngen (genom att f√• pekaren/adressen till var st√§ngen finns i minnet) som anv√§nds i caller-funktionen. 

A3:  Informationsg√∂mning
- Sj√§lva tanken med .c och .h filer √§r att vi ska kunna anv√§nda de funktioner och typer som vi skapar i .c filer n√§r vi k√∂r och skriver andra program (i andra filer) utan att kopiera √∂ver funktionerna i den "nya" filen, vilket skulle g√∂ra att det blir v√§ldigt m√•nga rader kod i bara en fil (minskar l√§sbarheten och f√∂rst√•elsen). D√§rf√∂r kan man anv√§nda en .h fil som bara har deklarationer av funktionerna i korresponerande .c fil, vilket √§ven g√∂r det l√§tt f√∂r programmeraren att veta vad f√∂r funktiner som finns .c filen utan bl√§ddra igenom en massa kod. 
- EXEMPEL: Vi g√∂mmer structs till hash_table och entry i .h filen eftersom de anv√§nds o b√•de hash_table.c och hash_table_tests.c. P√• detta vis slipper vi ha funktionerna i b√•da filerna.

J27: Manuell minneshantering
- Hur uppst√•r minnesl√§ckage? 
    SVAR: Minnesl√§ckor uppst√•r n√§r man allokerar minne i heapen men gl√∂mmer att ta bort det med free(). Detta inneb√§r att minnesplatsen anv√§nds, men inte utnyttjas effektivt, och man har allts√• f√∂rlorat potentiell plats f√∂r att lagra n√•got annat. Detta kan resultera i att programmet k√∂rs l√•ngsammare och i v√§rsta fall kraschar. 
- Vilken del av ett program ansvarar f√∂r att frig√∂ra minne?
    SVAR: free()?
- N√§r avg√∂r man att en bit allokerat minne √§r ‚Äúf√§rdiganv√§nt‚Äù och g√•r att frig√∂ra?
    SVAR: N√§r det som √§r lagrat p√• det allokerade minnet inte l√§ngre kommet att beh√∂vas anv√§ndas. Dvs, det anv√§nds inte mer i n√•gon funktion och ger inte l√§ngre n√•got syfte.
- Vad kan h√§nda om ett allokerat utrymme frig√∂rs ‚Äúf√∂r tidigt‚Äù?
    SVAR: Man kan f√• dangling pointers, dvs pointers som pekar till minne som inte √§r allokerat. Detta inneb√§r att den datan som pointern pekar p√•, inte l√§ngre √§r giltig, och skulle kunne best√• av vad som helst som vi inte kar kontroll √∂ver och ingen aning om vad det √§r.
- P√• vilket s√§tt hj√§lper valgrind dig att undvika minnesl√§ckage?
    SVAR: Valgrind f√∂rklarar hur mycke minne som allokeras samt frig√∂rs under ett programs livstid. Om det √§r mer minne som allokeras √§n frig√∂rs s√• uppst√•r minnesl√§ckor.

---------------------------------------------------------------------------------------------------------------
Redovisning m√•ndag 20 September:

F13: Iteration vs. rekursion
- length_of_bucket_recursive vs. length_of_bucket
- Det kan vara sv√•rare f√∂r en person som inte √§r s√• van vid rekursiva funktioner att f√∂rst√• hur den rekursiva funktionen fungerar j√§mf√∂r med hur den itterativa funktionen fungerar. 
- Iterativa funktioner kan alltid bli rekursiva, men rekursiva kan inte alltid bli iterativa. Rekursivt menas med att funktionen anropar sig sj√§lv. 
- B√•da anv√§nder bara stacken, d√§rmed inte s√• stor skillnad i prestanda. Det √§r n√§mligen skillnad i prestanda n√§r man anv√§nder stacken och n√§r man anv√§nder heapen 
- R√ñD TR√ÖD: Iteration och rekursion (i alla fall v√•ra funktioner) har anv√§nt sig av stacken, vilket tar oss in p√• vad skillnaden p√• stacken och heapen √§r

J26: Allokering p√• stacken vs. p√• heapen
- Se redovisning.c fil
- Stacken tar mycket snabbare tid ?
- Stack. Last in first out. V√§rden l√§ggs som "tallrikar" p√• stacken. En tallrik tas bort n√§r resultatet returneras.
- Heap: Beh√∂ver free() f√∂r att inte f√• minnesl√§ckage, vilket g√∂r att det kr√§vs mer rader kod √§n om man anv√§nder stacken. Om man inte anv√§nder free() s√• kan det p√•verka prestandan negativt pga minnesl√§ckage. F√∂rdelen √§r att du kommer √•t dina v√§rden mellan funktioner d√• de sparas i heapen j√§mf√∂rt med stacken som "f√∂rsvinner"/skrivs √∂ver n√§r n√§sta funktion k√∂r. 
- N√§r en funktion bara anv√§nder sig av stacken s√• "f√∂rsvinner" det som l√•g d√§r n√§r funktionen √§r klar. Du f√•r bara det returv√§rdet funktionen returnerade. Men om man anv√§nder sig av heapen s√• kan man komma √•t det √§ven mellan olika funktioner, oavsett vad funktionerna returnerar. 
- J√§mf√∂relse med fib(35): Stack = 0s , Heap = 2.68s
- J√§mf√∂relse med fib(45): Stack = 8.55s, Heap = F√∂r l√•ng tid
- Slutsats: Om man kan h√•lla sig till stacken s√• b√∂r man g√∂ra det, eftersom den har mycket h√∂gre prestanda. Om det beh√∂vs en minnesplats s√• m√•ste man dock anv√§nda sig av heapen.
- R√ñD TR√ÖD: Minneshantering anv√§nder sig av pekare vilket tar oss vidare till M36, som handlar om arrayer och pekare. 

M36: C:s array-notation och pekararitmetik
- Argumentvektorn till main-funktionen
    SVAR: main(int argc, char *argv[]). Det som skickas in som argument till main blir en array.
- Vad √∂vers√§tts arr[42] till? 
    SVAR: Det 43:e elementet i arrayen "arr". Pga index b√∂rjar p√• 0. 
- Vad √∂vers√§tts 42[arr] till? (detta kompilerar faktiskt, trots att det ser vansinigt ut)
    SVAR: Samma; 43:e elementet i arrayen "arr". Se redovisning.c.
- Det som √§r innanf√∂r [] √§r offset fr√•n minnesplatsen, vilket inneb√§r att a[b] och b[a] ger samma adress.
- R√ñD TR√ÖD: Identitet pch ekvivalens h√∂r ihop med pekare

H19: Skillnaden mellan identitet och ekvivalens
- Identitet: "samma st√§ng". 
    char *test1 = "test"
    char *test2 = test1
- Ekvivalens: "Inneh√•ller samma st√§ng". tex en kopia av en str√§ng, det √§r tv√• str√§nger men de inneh√•ller likadan info
            En omodifierad kopia av original str√§ngen
    char *test1 = "Hej!"
    char *test2 = "Hej!"

---------------------------------------------------------------------------------------------------------------
Redovisning Torsdag 23 September:

R52: Debuggning med GDB

F14: Svansrekursion




REDOVISNING M√ÖNDAG 27 september:


E10: Man kan skapa generella funktioner genom att anv√§nda void-pekare, tex apply_all funktionen. 
Den kan i v√•rat exempel anv√§nda sig av tv√• olika hj√§lpfunktioner; value_equiv och key_equiv. Dessa hj√§lpfunktioner tar olika argumenttyper, vilket v√•r voidpekar-argument i apply_all funktionen m√∂jligg√∂r. C vet fr√•n b√∂rjan inte vad den ska tolka argumentet som f√∂r typ, men beroende p√• vilken hj√§lpfunktion man anv√§nder s√• tolkar den voidpekar-argumentet p√• olika s√§tt. Med detta sagt s√• har funktionen en viss genericitet.Vi kan visa det i v√•ra tester...

R√ñD TR√ÖD:
Nu har vi sett att vi kan ha olika typer av argument p√• samma funktion mha void-pekare i v√•ra tester, men hur vet vi att v√•ra tester √§r bra?

Q50: 
- Hur vet man att de test man har √§r ‚Äúbra‚Äù? 
    Ett bra enhetstest kan k√∂ras helt automatiserat, √§r l√§sbart och pr√∂var endast en enda logisk funktion/koncept. Man kan inte veta om ett test √§r bra. Det man kan resonera om √§r om ett test lyckas misslyckas, s√• hj√§lper det med att √•tg√§rda fel i en funktion, och d√§rmed √§r det bra eftersom det gjort nytta. 
- Hur vet man vad testen egentligen testar?
- Anv√§nd ett l√§mpligt verktyg f√∂r att t.ex. m√§ta code coverage, d.v.s. hur stor del av koden som faktiskt testas av testen. 
    Visa med ioopm_hash_table_remove: F√∂re test 7B och efter test 7B lagts till
- Vilka andra kvalitetsm√•tt p√• tester finns? 
    Hur l√§sbart det √§r? Om det t√§cker alla basfall och edgecases. LCOV, f√•r fram en code coverage report. 
- M√•ste man testa sina tester? 
    Nej man m√•ste "n√∂ja" sig n√•gonstanns. Annars kan man forts√§tta i alla o√§ndlighet. 
- M√•ste man testa testernas tester? Blir inte detta en o√§ndlig regression?


--------------------------------------------------------------------------------------------------------------------------------

REDOVISNING FREDAG 1 OKTOBER

I22: Defensiv programmering
- Defensiv programmering √§r en slags "approach" som ska f√∂rb√§ttra kod genom att minska antalet buggar och problem, se till att koden √§r l√§sbar och se till att programmet beter sig f√∂ruts√§gbart oavsett vilka inputs som anges.
- F√∂rdelarna med att ha defensiv programmering i √•tanke √§r bland annat att man undviker vissa fel som annars skulle tagit tid att √•tg√§rda.
- En typ av defensiv programmering √§r "offensiv programmering", som ist√§llet fokuserar p√• hur fel som uppst√•r utanf√∂r programmet hanteras. Man litar allts√• p√• att programmet fungerar och ist√§llet bara kollar att till exempel inputs √§r korrekta. EXEMPEL: ioopm_lookup_key i hash_table.c skriver ut "This key does not map to anything!" om inte s√∂kt key finns. Detta kan anv√§ndas som en check till andra funktioner f√∂r att kolla att en input √§r valid.
- Att √•teranv√§nda kod √§r en typ av defensiv programmering OM man har testat just den delen och vet att den fungerar. 
    EXEMPEL: F√∂rst skrev vi klart alla hash table funktioner och s√•g till att de fungerade med olika tester. N√§r vi sedan skulle b√∂rja med linked list s√• ins√•g vi att det var m√•nga v√§ldigt lika funktioner, och att en linked list s√•g v√§ldigt lik ut hur en bucket s√•g ut i ett hash table. Vi kunde d√§rf√∂r anv√§nda hur v√•r kod s√•g ut i hash table och f√∂ra √∂ver det till linked list funktionerna. TEX all, any och apply ta all funktionerna. 
- Assertions: kan skydda programmet fr√•n att utf√∂ra n√•got som inte √§r korrekt. Dessa b√∂r enbart anv√§ndas f√∂r saker som aldrig borde kunna uppst√•. EXEMPEL: linked list RAD 94, man ska aldrig kunna skicka in ett index som √§r utanf√∂r storleken p√• listan.
- Exceptions: Detta f√∂rklarar vi i felhanteringen
- Previllkor: Ett villkor eller predikat som m√•ste st√§mma INNAN en del av en kod utf√∂rs. Brukar inkluderas i dokumentationen av den delen av kod som det ber√∂r. EXEMPEL: linked_list_insert index m√•ste vara inom [0,N] d√§r N √§r l√§ngden p√• listan (st√•r i .h fil).
- Postvillkor: Ett villkor eller predikat som m√•ste st√§mma EFTER en del av en kod utf√∂rs. Assertions kan anv√§ndas f√∂r att testa om det st√§mmer. Brukar inkluderas i dokumentationen av den delen av kod som det ber√∂r. 
- Informationsg√∂mningsprincipen: Inkapsling √§r en typ av infomrationsg√∂mning. Man "g√∂mmer" saker bakom ett gr√§nssnitt. Informationsg√∂mning √§r viktigt f√∂r att skydda fr√•n l√§ckande abstaktioner. EXEMPEL: inkapsling i remove funktioner
- Hj√§lpfunktioner: Hj√§lper fel√∂kning genom att man kan testa en mindre del av koden i taget. EXEMPEL: find_previous_entry_for_key. TEX: find previous entry for key. Tidigare s√• fick vi en bugg i v√•r lookup funktion, som anv√§nder sig av find_previous_entry_for_key. Genom att g√∂ra testfall p√• den f√∂rst s√• kunde vi utesluta att det var i den delen av koden som buggen l√•g. 

- R√ñD TR√ÖD: Defensiv programmering √§r en typ av felhantering, vilket leder oss in p√• m√•l I24: "Olika metoder f√∂r felhantering".
- R√ñD TR√ÖD: Det kan g√• fel med aliasering tex och kan hittas med hj√§lp av defensiv programmering.

I24: Olika metoder f√∂r felhantering
- Crash don‚Äôt trash: Det √§r viktigt att uppt√§cka fel s√• fort som m√∂jligt. Om ett fel kan finnas fort s√• inneb√§r det att man kan l√•ta ett program krascha tidigare. F√∂rdelen med att krascha kan vara att man undviker att korrupt data skrivs och l√§ses. Med en krasch kan man ist√§llet f√• information om vad som g√•tt fel, ist√§llet f√∂r att f√• andra typer av fel.
- Defensiv programmering: Detta har vi redan f√∂rklarat. 
- Undantagshantering: Ett exception (eller undantag) √§r ett problem som uppst√•r vid utf√∂randet av ett program. N√§r ett exception uppst√•r s√• avbryts programmet, vilket inte alltid √§r eftertraktat, s√• ist√§llet s√• kan man hantera dessa undantag genom att "kasta" och "f√•nga" exceptions, s√• att det g√•r att k√∂ra vidare programmet. Ett try/catch block √§r ett sats som k√∂r en kod som √§r ben√§gen att orsaka exceptions i try-delen och om undantag uppst√•r s√• hanterar catch-delen det. Man kan ha flera catch-delar f√∂r olika typer av undantag. Om ett undantag inte hanteras s√• m√•ste man ange det med en "throw". Det g√•r att skriva sina egna undantag ocks√•. 
- Hur fel hanteras i C med errno: errno √§r en form av global variabel i C som indikerar errors som uppkommer under ett funktionsanrop. Det finns en header fil vid namn "error.h" d√§r olika errorkoder √§r definierade. Det finns √§ven perror() och sterror() funktioner som anv√§nds f√∂r att visa det textmeddelande som √§r kopplat till en viss errno errorkod. 
- Konsekvens att byta mellan felhanteringsmetoder i ett program: Man kommer beh√∂va skriva om sina funktioner och testa att de nya felhanteringmetoderna fungerar som f√∂rv√§ntat. 

G15: Aliasering
- Aliasering - data kan delas mellan olika objekt. En f√∂r√§ndring som sker via en pekare kan bli synlig f√∂r alla andra funktioner, eller liknande, som har en pekare till samma data. 
- Tex i linked_list.c har vi en remove funktion som tar bort det element ur listan som ligger p√• det index som man skickade in i funktionen. I v√•r struct s√• har vi first och last pekare, sedan s√• har vi √§ven pekare mellan elementen i listan. Om vi tex skulle ta bort det sista elementet i listan med hj√§lp av v√•r remove funktion s√• skulle listan pekas om (sista elementet frig√∂rs, det nya sista elementet pekar p√• null osv). Om vi nu skulle ta ut v√§rdet p√• list->last s√• skulle det ha √§ndrats om, utan att vi anv√§nt oss av last pekaren.
- Det h√§r kan vara ett problem ocks√•. Om vi hade gl√∂mt att peka om last pekaren n√§r vi tar bort det sista elementet s√• uppst√•r det problem. N√§r vi d√• f√∂rs√∂ker komma √•t datan med hj√§lp av last pekaren s√• kommer den f√∂rs√∂ka accessa minne som inte l√§ngre √§r allokerat.  
( KASNKE ON√ñDIGT? KAN SVARA OM DE FR√ÖGAR HUR MAN KAN UNDVIKA PROBELM - Ett s√§tt att undvika detta √§r att med hj√§lp av kopiering. Man kopierar d√• det v√§rde man beh√∂ver och kan d√• √§ndra p√• det ist√§llet. Men just i v√•rt fall s√• beh√∂vs inte det, d√• vi faktiskt vill √§ndra b√•de i listan och i last pekaren.)




FR√ÖGA X59: Ess√§
- Vilket m√•l p√• niv√• 4/5 √§r l√§mplig att redovisa med en ess√§?

FR√ÖGA TODO P45: G√∂r en informell kodgranskning under fas 1 
- N√§r √§r det l√§mpligt att g√∂ra denna?

Saker att g√∂ra / kom ih√•g!

-------------------------------------------------------------------------------------------------------------
GDB LATHUND:
 https://dev.to/jasonelwood/setup-gdb-on-macos-in-2020-489k (gdb f√∂r mac )

make hash_table

gdb ./a.out ./

b main (vart du vill ha breakpoint, tex b 147 (breakpoint p√• rad 147))

r - run (kom ih√•g argument om du har)

n - n√§sta rader

s - "steppa" in i funktionen du √§r vid

p - print value, vad det √§r just d√•.

q - quit

PLANERING:

Ca 1 step om dagen.
Ska vara klar till soft deadline
Ta ca 3-4 m√•l varje redovisning. Planerar ca 1/2 dagar innan redovisningstillf√§llet. 